from 木兰.生成 import 木兰

import ast
import os
import unittest
import subprocess
from sys import platform

为win系统 = platform == 'win32'
原始可执行文件 = "ulang-0.2.2.exe"
头部信息 = "/* 本文件由命令 `木兰 -兰 ` 自动生成. */\n"
if 为win系统:
    头部信息 = "/* This file is auto-generated by the command `ulang -s `. */\n"

# TODO: 确保生成的木兰代码运行效果与 Python 相同
# 如果用例与木兰功能测试用例有相当重合，考虑复用

源码目录 = "测试/unittest/源码生成/"

原始木兰未过 = {
    "测试/unittest/源码生成/函数/变长指名参数": "TypeError: can only concatenate str (not \"arg\") to str",
    #"测试/unittest/源码生成/类型/属性": "NameError: name 'decorator_list' is not defined",
}


class test所有(unittest.TestCase):

    def test(self):

        for 路径, 目录名, 所有文件 in os.walk(源码目录):
            for 文件 in 所有文件:
                文件名 = os.path.splitext(os.path.join(路径, 文件))
                if 文件名[1] == '.py' and 文件名[0] not in 原始木兰未过:
                    self.比较(文件名[0])

    def 比较(self, python文件名):
        python路径 = python文件名 + '.py'
        with open(python路径, 'r', encoding='utf-8') as f:
            python源码 = f.read()

        木兰路径 = python文件名 + ".ul"
        if os.path.isfile(木兰路径):
            with open(木兰路径, 'r', encoding='utf-8') as f:
                木兰源码 = f.read()
        else:
            木兰源码 = python源码

        if 为win系统:
            进程 = subprocess.Popen([原始可执行文件, '-s', python路径], stdout=subprocess.PIPE)
            反馈 = 进程.communicate()
            生成源码 = 反馈[0]
            self.assertEqual(生成源码.decode("utf-8").replace("\r\n", "\n"),
                头部信息 + "\n" + 木兰源码 + "\n",
                python路径 + " 转换错误")
        else:
            语法树节点 = ast.parse(python源码, python路径)
            生成器 = 木兰.木兰生成器("  ", 头部信息)
            生成器.visit(语法树节点)
            生成源码 = "".join(生成器.结果)
            self.assertEqual(生成源码, 头部信息 + "\n" + 木兰源码, python路径 + " 转换错误")
