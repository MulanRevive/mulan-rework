using 点 in 测试.实用.规划.点
using 相等 in 测试.实用.通用.测试相关
using 按某项生成映射 in 测试.实用.通用.结构

type 范围 {
  func $范围(所有坐标) {
    self.所有点 = list(map(坐标数组 -> 点(坐标数组[0], 坐标数组[1]), 所有坐标))
  }

  func 创建方阵(长, 宽) {
    所有点 = []
    for 纵坐标 in (宽 - 1)..0 by -1 {
      for 横坐标 in 0..<长 {
        所有点.append([横坐标, 纵坐标])
      }
    }
    return 范围(所有点)
  }

  func 包含点(self, 点) {
    return any(map(某点 -> 某点 == 点, self.所有点))
  }

  func 未超出(self, 某范围) {
    return len(某范围.所有点) >= len(self.所有点) and
          all(map(某点 -> 某范围.包含点(某点), self.所有点))
  }

  /* 仅处理横纵轴上的点 */
  func 顺时针转90度(self) {
    return 范围(list(map(某点 -> [某点.纵, -某点.横], self.所有点)))
  }

  func 除去(self, 某块) {
    新范围 = 范围([])
    新范围.所有点 = list(filter(某点 -> !某块.包含点(某点), self.所有点))
    return 新范围
  }

  func 可视化(self) {
    行 = max(map(某点 -> 某点.纵, self.所有点))
    点表 = 按某项生成映射(self.所有点, 某点 -> 某点.纵, 某点 -> 某点.横)
    输出 = ""
    for 行号 in 0..行 {
      最大列号 = max(点表[行号])
      行 = " " * (最大列号 + 1)
      for 列号 in 点表[行号] {
        行 = 行[:列号] + "○" + 行[列号 + 1:]
      }
      行 += "\n"
      输出 = 行 + 输出
    }
    return 输出
  }

  operator == (另一范围) {
    return len(另一范围.所有点) == len(self.所有点) and self.未超出(另一范围)
  }

  func __repr__(self) {
    return len(self.所有点) == 0 ? "空" : "点阵: " + " ".join(map(str, self.所有点))
  }
}

// [x, y]
全区 = 范围.创建方阵(4, 4).除去(范围([
  [0, 3], [3, 3],
  [0, 0]
]))

部分区域 = 全区.除去(范围([
  [0, 1], [2, 1],
          [2, 0]
]))

二乘二 = 范围.创建方阵(2, 2)

三格 = 范围([[-1, 0], [0, 0], [1, 0]])

// [0, 0] 为中心，其他为相对坐标。按照实际形状进行排列，以便阅读。
长折 = 范围([
    [0, 2],
    [0, 1],
    [0, 0], [1, 0]
  ])

短折 = 范围([
    [0, 1],
    [0, 0], [1, 0]
  ])

一字 = 范围([[-1, 0], [0, 0], [1, 0]])

相等(true, 二乘二.包含点(点(1, 1)), "包含点")

相等(范围([
      [0, 0], [1, 0],
      [0, -1]
    ]), 短折.顺时针转90度(), "右旋90度")

相等(true, 短折.未超出(二乘二), "未超出")

相等(范围([[1, 1]]), 二乘二.除去(短折), "除去")

相等(范围([
      [0, 1], [1, 1],
      [0, 0], [1, 0]
    ]), 范围.创建方阵(2, 2), "创建方阵")

相等("○○\n○○\n", 二乘二.可视化(), "可视化")
相等(" ○○\n○○○○\n○○○○\n ○○○\n", 全区.可视化(), "可视化")
