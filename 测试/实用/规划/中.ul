using 点 in 测试.实用.规划.点
using 范围, 全区, 部分区域, 二乘二, 三格, 长折, 短折, 一字 in 测试.实用.规划.范围
using 占地 in 测试.实用.规划.占地
using 相等 in 测试.实用.通用.测试相关

// 需记录占据情况

// TODO: 指定形参的类型
func 各种朝向(初始形状){
  所有形状 = [初始形状]
  转后形状 = 初始形状
  for 旋转次数 in 1..3 {
    转后形状 = 转后形状.顺时针转90度()

    if 转后形状 != 初始形状 {
      所有形状.append(转后形状)
    } else {
      break
    }
  }
  return 所有形状
}

func 可放位置(形状, 区域) {
  所有位置 = []
  各朝向的形状 = 各种朝向(形状)
  for 某形 in 各朝向的形状 {
    for 定点 in 区域.所有点 {
      该形占地 = 占地(某形, 定点)
      该形范围 = 该形占地.范围
      所有位置.append([该形占地, 区域.除去(该形范围)]) if 该形范围.未超出(区域)
    }
  }
  return 所有位置
}

// TODO: 返回值类型化(实际上也是更可读(省去文档说明))
func 取所有摆放方案(之前方案, 区域, 所有形状) {
  //println("形状数 " + str(len(所有形状)))
  // 最后结构
  if len(所有形状) == 0 {
    return [[之前方案, 区域]]
  }
  首个形状 = 所有形状[0]
  该形状可放位置 = 可放位置(首个形状, 区域)
  所有方案 = []
  // [占地, 剩余区域]
  for 某位置 in 该形状可放位置 {
    占地 = 某位置[0]
    剩余区域 = 某位置[1]

    //println("新方案: " + str(之前方案))
    //[形1位置 + 形2信息[0] + 形3信息[0], 形3信息[1]])
    所有方案 = 所有方案 + 取所有摆放方案(之前方案 + [占地], 剩余区域, 所有形状[1:])
  }
  return 所有方案
}

// TODO: 方案可视化
for 方案 in 取所有摆放方案([], 部分区域, [长折, 短折, 一字]) {
  println(方案)
}

print(全区.可视化())

// TODO: 指定三个定点求解

/******* 测试 ******/

相等([
  范围([[-1, 0], [0, 0], [1, 0]]),
  范围([
    [0, 1],
    [0, 0],
    [0, -1]
  ])
], 各种朝向(一字), "一字各种朝向")

相等(4, len(可放位置(短折, 二乘二)), "可放位置")

相等(1, len(取所有摆放方案([], 三格, [一字])), "取所有摆放方案1")
相等(4, len(取所有摆放方案([], 二乘二, [短折])), "取所有摆放方案2")
相等(62, len(取所有摆放方案([], 全区, [长折, 短折, 一字])), "取所有摆放方案3")
