type 点 {
    func $点(横, 纵) {
      self.横, self.纵 = 横, 纵
    }

    operator == (另一点) {
      return self.横 == 另一点.横 and self.纵 == 另一点.纵
    }

    func __repr__(self) {
      return "点(" + str(self.横) + ", " + str(self.纵) + ")"
    }
}

type 范围 {
  func $范围(所有坐标) {
    self.所有点 = list(map(坐标数组 -> 点(坐标数组[0], 坐标数组[1]), 所有坐标))
  }

  func 包含点(self, 点) {
    return any(map(某点 -> 某点 == 点, self.所有点))
  }

  func 未超出范围(self, 大范围) {
    return len(大范围.所有点) >= len(self.所有点) and
          all(map(某点 -> 大范围.包含点(某点), self.所有点))
  }

  /* 仅处理横纵轴上的点 */
  func 顺时针90度(self) {
    return 范围(list(map(某点 -> [某点.纵, -某点.横], self.所有点)))
  }

  func 偏移(self, 定点) {
    横偏移 = 定点.横
    纵偏移 = 定点.纵
    return 范围(list(map(某点 -> [某点.横 + 横偏移, 某点.纵 + 纵偏移], self.所有点)))
  }

  func 除去(self, 某块) {
    新范围 = 范围([])
    新范围.所有点 = list(filter(某点 -> !某块.包含点(某点), self.所有点))
    return 新范围
  }

  operator == (另一范围) {
    return len(另一范围.所有点) == len(self.所有点) and self.未超出范围(另一范围)
  }

  func __repr__(self) {
    文本 = "范围:{ "
    for 点 in self.所有点 {
      文本 = 文本 + str(点) + " "
    }
    文本 = 文本 + "}"
    return 文本
  }
}

// [x, y]
全区 = 范围([
          [1, 3], [2, 3],
  [0, 2], [1, 2], [2, 2], [3, 2],
  [0, 1], [1, 1], [2, 1], [3, 1],
          [1, 0], [2, 0], [3, 0]
])

部分区域 = 范围([
          [1, 3], [2, 3],
  [0, 2], [1, 2], [2, 2], [3, 2],
  /*[0, 1],*/ [1, 1], /*[2, 1],*/ [3, 1],
          [1, 0], /*[2, 0],*/ [3, 0] 
])

二乘二 = 范围([
  [0, 1], [1, 1],
  [0, 0], [1, 0]
])

三格 = 范围([[-1, 0], [0, 0], [1, 0]])

// 需记录占据情况

func 获取所有旋转(初始形状) {
  所有形状 = [初始形状]
  转后形状 = 初始形状
  for 旋转次数 in 1..3 {
    转后形状 = 转后形状.顺时针90度()

    if !any(map(之前形状 -> 转后形状 == 之前形状, 所有形状[0:旋转次数])) {
      所有形状.append(转后形状)
    }
  }
  return 所有形状
}

// [0, 0] 为中心，当前位置为 0，顺时针旋转 90 后为 1，依次为位置 2，3
长折 = 获取所有旋转(范围([
    [0, 2],
    [0, 1],
    [0, 0], [1, 0]
  ]))

短折 = 获取所有旋转(范围([
    [0, 1],
    [0, 0], [1, 0]
  ]))

一字 = 获取所有旋转(范围([[-1, 0], [0, 0], [1, 0]]))

func 可能位置(形状, 区域) {
  所有位置 = []
  for 某形 in 形状 {
    for 定点 in 区域.所有点 {
      占位 = 某形.偏移(定点)
      // 占位是否在区域内
      if 占位.未超出范围(区域) {
        所有位置.append([[某形, 定点], 区域.除去(占位)])
      }
    }
  }
  return 所有位置
}

// TODO: 返回值类型化(实际上也是更可读(省去文档说明))
func 取所有摆放方法(区域, 形1, 形2, 形3) {
  所有位置 = []
  放形1 = 可能位置(形1, 区域)
  for 形1信息 in 放形1 {
    // println(形1信息)
    形1位置 = 形1信息[0]
    剩余区域 = 形1信息[1]
    放形2 = 可能位置(形2, 剩余区域)
    for 形2信息 in 放形2 {
      放形3 = 可能位置(形3, 形2信息[1])
      if len(放形3) > 0 {
        for 形3信息 in 放形3 {
          所有位置.append([形1位置 + 形2信息[0] + 形3信息[0], 形3信息[1]])
        }
      }
    }
  }
  return 所有位置
}

func 取所有摆放方案(之前方案, 区域, 所有形状) {
  //println("形状数 " + str(len(所有形状)))
  // 最后结构
  if len(所有形状) == 0 {
    return [[之前方案, 区域]]
  }
  首个形状 = 所有形状[0]
  某形状位置 = 可能位置(首个形状, 区域)
  // println("可能位置 " + str(len(某形状位置)))
  所有方案 = []
  // [[某形, 定点], 区域.除去(占位)]
  for 某变形位置 in 某形状位置 {
    变形与位置 = 某变形位置[0] // [某形, 定点]
    剩余区域 = 某变形位置[1]

    之前方案.append(变形与位置)

    //println("新方案: " + str(之前方案))
    //[形1位置 + 形2信息[0] + 形3信息[0], 形3信息[1]])
    所有方案 = 所有方案 + 取所有摆放方案(之前方案, 剩余区域, 所有形状[1:len(所有形状)])
  }
  return 所有方案
}

// println(取所有摆放方案([], 三格, [一字])) // 1

for 方案 in 取所有摆放方案([], 二乘二, [短折]) {
  println(方案)
}  // 4
println(len(取所有摆放方案([], 全区, [长折, 短折, 一字])))  // 62
//println(len(取所有摆放方法(全区, 长折, 短折, 一字)))

// TODO: 方案可视化
//println(取所有摆放方案([], 部分区域, [长折, 短折, 一字]))  // 1
//println(点(100, 200))
//println(二乘二)
//println([二乘二])
// TODO: 指定三个定点求解

/******* 测试 ******/

func 相等(目标, 实际, 信息) {
  值 = 实际
  if 值 != 目标 {
    println(信息 + "出错 -- 目标: " + str(目标) + ", 但实际为: " + str(值))
  }
}

相等(0, 点(0, 1).横, "点横坐标")
相等(1, 点(0, 1).纵, "点纵坐标")
相等(true, 点(0, 1) == 点(0, 1), "点相等")
相等(false, 点(1, 1) == 点(0, 1), "点不相等")
相等(true, 二乘二.包含点(点(1, 1)), "包含点")

相等(范围([[1, 0], [0, 0], [0, -1]]), 范围([
    [0, 1],
    [0, 0], [1, 0]
  ]).顺时针90度(), "右旋90度")

相等(范围([
    [1, 2],
    [1, 1], [2, 1]
  ]), 范围([
    [0, 1],
    [0, 0], [1, 0]
  ]).偏移(点(1, 1)), "偏移")

相等(true, 范围([
    [0, 1],
    [0, 0], [1, 0]
  ]).未超出范围(二乘二), "未超出范围")

相等(范围([[1, 1]]),
    二乘二.除去(
      范围([
        [0, 1],
        [0, 0], [1, 0]
      ])),
    "除去")

相等([
  范围([[-1, 0], [0, 0], [1, 0]]),
  范围([
    [0, 1],
    [0, 0],
    [0, -1]
  ])
], 获取所有旋转(范围([[-1, 0], [0, 0], [1, 0]])), "一字获取所有旋转")

相等(4,
  len(
    可能位置(
      获取所有旋转(范围([
        [0, 1],
        [0, 0], [1, 0]
      ])),
      二乘二
    )
  ), "可能位置")
