type 点 {
    func $点(横, 纵) {
      self.横, self.纵 = 横, 纵
    }

    operator == (另一点) {
      return self.横 == 另一点.横 and self.纵 == 另一点.纵
    }
}

type 范围 {
  func $范围(所有坐标) {
    self.所有点 = list(map(坐标数组 -> 点(坐标数组[0], 坐标数组[1]), 所有坐标))
  }

  func 包含点(self, 点) {
    return any(map(某点 -> 某点 == 点, self.所有点))
  }

  func 未超出范围(self, 大范围) {
    return len(大范围.所有点) >= len(self.所有点) and
          all(map(某点 -> 大范围.包含点(某点), self.所有点))
  }

  /* 仅处理横纵轴上的点 */
  func 顺时针90度(self) {
    return 范围(list(map(某点 -> [某点.纵, -某点.横], self.所有点)))
  }

  // TODO: 坐标改为点
  func 偏移(self, 偏移坐标) {
    横偏移 = 偏移坐标[0]
    纵偏移 = 偏移坐标[1]
    return 范围(list(map(某点 -> [某点.横 + 横偏移, 某点.纵 + 纵偏移], self.所有点)))
  }

  func 除去(self, 某块) {
    新范围 = 范围([])
    新范围.所有点 = list(filter(某点 -> !某块.包含点(某点), self.所有点))
    return 新范围
  }

  operator == (另一范围) {
    return len(另一范围.所有点) == len(self.所有点) and self.未超出范围(另一范围)
  }
}

// [x, y]
全区 = 范围([
          [1, 3], [2, 3],
  [0, 2], [1, 2], [2, 2], [3, 2],
  [0, 1], [1, 1], [2, 1], [3, 1],
          [1, 0], [2, 0], [3, 0]
])

部分区域 = 范围([
          [1, 3], [2, 3],
  [0, 2], [1, 2], [2, 2], [3, 2],
  /*[0, 1],*/ [1, 1], /*[2, 1],*/ [3, 1],
          [1, 0], /*[2, 0],*/ [3, 0] 
])

二乘二 = 范围([
  [0, 1], [1, 1],
  [0, 0], [1, 0]
])

// 需记录占据情况

func 获取所有旋转(初始形状) {
  所有形状 = [初始形状]
  转后形状 = 初始形状
  for 旋转次数 in 1..3 {
    转后形状 = 转后形状.顺时针90度()

    if !any(map(之前形状 -> 转后形状 == 之前形状, 所有形状[0:旋转次数])) {
      所有形状.append(转后形状)
    }
  }
  return 所有形状
}

// [0, 0] 为中心，当前位置为 0，顺时针旋转 90 后为 1，依次为位置 2，3
长折 = 获取所有旋转(范围([
    [0, 2],
    [0, 1],
    [0, 0], [1, 0]
  ]))

短折 = 获取所有旋转(范围([
    [0, 1],
    [0, 0], [1, 0]
  ]))

一字 = 获取所有旋转(范围([[-1, 0], [0, 0], [1, 0]]))

func 可能位置(形状, 区域) {
  所有位置 = []
  for 某形 in 形状 {
    for 定点 in 区域.所有点 {
      占位 = 某形.偏移([定点.横, 定点.纵])
      // 占位是否在区域内
      if 占位.未超出范围(区域) {
        所有位置.append([[某形, 定点], 区域.除去(占位)])
      }
    }
  }
  return 所有位置
}

// TODO: 返回值类型化(实际上也是更可读(省去文档说明))
func 取所有摆放方法(区域, 形1, 形2, 形3) {
  所有位置 = []
  放形1 = 可能位置(形1, 区域)
  for 形1信息 in 放形1 {
    // println(形1信息)
    形1位置 = 形1信息[0]
    剩余区域 = 形1信息[1]
    放形2 = 可能位置(形2, 剩余区域)
    for 形2信息 in 放形2 {
      放形3 = 可能位置(形3, 形2信息[1])
      if len(放形3) > 0 {
        for 形3信息 in 放形3 {
          所有位置.append([形1位置 + 形2信息[0] + 形3信息[0], 形3信息[1]])
        }
      }
    }
  }
  return 所有位置
}

println(len(取所有摆放方法(全区, 长折, 短折, 一字)))
println(len(取所有摆放方法(部分区域, 长折, 短折, 一字)))

// TODO: 指定三个定点求解

/******* 测试 ******/

func 相等(目标, 实际, 信息) {
  值 = 实际
  if 值 != 目标 {
    println(信息 + "出错 -- 目标: " + str(目标) + ", 但实际为: " + str(值))
  }
}

相等(0, 点(0, 1).横, "点横坐标")
相等(1, 点(0, 1).纵, "点纵坐标")
相等(true, 点(0, 1) == 点(0, 1), "点相等")
相等(false, 点(1, 1) == 点(0, 1), "点不相等")
相等(true, 二乘二.包含点(点(1, 1)), "包含点")

相等(范围([[1, 0], [0, 0], [0, -1]]), 范围([
    [0, 1],
    [0, 0], [1, 0]
  ]).顺时针90度(), "右旋90度")

相等(范围([
    [1, 2],
    [1, 1], [2, 1]
  ]), 范围([
    [0, 1],
    [0, 0], [1, 0]
  ]).偏移([1, 1]), "偏移")

相等(true, 范围([
    [0, 1],
    [0, 0], [1, 0]
  ]).未超出范围(二乘二), "未超出范围")

相等(范围([[1, 1]]),
    二乘二.除去(
      范围([
        [0, 1],
        [0, 0], [1, 0]
      ])),
    "除去")

相等([
  范围([[-1, 0], [0, 0], [1, 0]]),
  范围([
    [0, 1],
    [0, 0],
    [0, -1]
  ])
], 获取所有旋转(范围([[-1, 0], [0, 0], [1, 0]])), "一字获取所有旋转")

相等(4,
  len(
    可能位置(
      获取所有旋转(范围([
        [0, 1],
        [0, 0], [1, 0]
      ])),
      二乘二
    )
  ), "可能位置")
