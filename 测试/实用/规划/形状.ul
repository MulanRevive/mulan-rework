// TODO：抽取到其他文件
type 点 {
    func $点(横, 纵) {
      self.横, self.纵 = 横, 纵
    }

    operator == (另一点) {
      return self.横 == 另一点.横 and self.纵 == 另一点.纵
    }

    func __repr__(self) {
      return "(" + str(self.横) + ", " + str(self.纵) + ")"
    }
}

type 范围 {
  func $范围(所有坐标) {
    self.所有点 = list(map(坐标数组 -> 点(坐标数组[0], 坐标数组[1]), 所有坐标))
  }

  func 包含点(self, 点) {
    return any(map(某点 -> 某点 == 点, self.所有点))
  }

  func 未超出(self, 某范围) {
    return len(某范围.所有点) >= len(self.所有点) and
          all(map(某点 -> 某范围.包含点(某点), self.所有点))
  }

  /* 仅处理横纵轴上的点 */
  func 顺时针转90度(self) {
    return 范围(list(map(某点 -> [某点.纵, -某点.横], self.所有点)))
  }

  func 除去(self, 某块) {
    新范围 = 范围([])
    新范围.所有点 = list(filter(某点 -> !某块.包含点(某点), self.所有点))
    return 新范围
  }

  operator == (另一范围) {
    return len(另一范围.所有点) == len(self.所有点) and self.未超出(另一范围)
  }

  func __repr__(self) {
    return len(self.所有点) == 0 ? "空" : "点阵: " + " ".join(map(str, self.所有点))
  }
}

type 占地 {
  func $占地(某范围, 原点) {
    self.原点 = 原点

    横偏移 = 原点.横
    纵偏移 = 原点.纵
    self.范围 = 范围(list(map(某点 -> [某点.横 + 横偏移, 某点.纵 + 纵偏移], 某范围.所有点)))
  }

  func __repr__(self) {
    return "中心为" + str(self.原点) + "的" + str(self.范围)
  }
}

// [x, y]
// TODO: 改为 4x4 除去 3 个点
全区 = 范围([
          [1, 3], [2, 3],
  [0, 2], [1, 2], [2, 2], [3, 2],
  [0, 1], [1, 1], [2, 1], [3, 1],
          [1, 0], [2, 0], [3, 0]
])

部分区域 = 范围([
          [1, 3], [2, 3],
  [0, 2], [1, 2], [2, 2], [3, 2],
  /*[0, 1],*/ [1, 1], /*[2, 1],*/ [3, 1],
          [1, 0], /*[2, 0],*/ [3, 0] 
])

// TODO: 简化 axa 方格的创建
二乘二 = 范围([
  [0, 1], [1, 1],
  [0, 0], [1, 0]
])

三格 = 范围([[-1, 0], [0, 0], [1, 0]])

// 需记录占据情况

// TODO: 指定形参的类型
func 各种朝向(初始形状){
  所有形状 = [初始形状]
  转后形状 = 初始形状
  for 旋转次数 in 1..3 {
    转后形状 = 转后形状.顺时针转90度()

    if 转后形状 != 初始形状 {
      所有形状.append(转后形状)
    } else {
      break
    }
  }
  return 所有形状
}

// [0, 0] 为中心，其他为相对坐标。按照实际形状进行排列，以便阅读。
长折 = 范围([
    [0, 2],
    [0, 1],
    [0, 0], [1, 0]
  ])

短折 = 范围([
    [0, 1],
    [0, 0], [1, 0]
  ])

一字 = 范围([[-1, 0], [0, 0], [1, 0]])

func 可放位置(形状, 区域) {
  所有位置 = []
  各朝向的形状 = 各种朝向(形状)
  for 某形 in 各朝向的形状 {
    for 定点 in 区域.所有点 {
      该形占地 = 占地(某形, 定点)
      该形范围 = 该形占地.范围
      所有位置.append([该形占地, 区域.除去(该形范围)]) if 该形范围.未超出(区域)
    }
  }
  return 所有位置
}

// TODO: 返回值类型化(实际上也是更可读(省去文档说明))
func 取所有摆放方案(之前方案, 区域, 所有形状) {
  //println("形状数 " + str(len(所有形状)))
  // 最后结构
  if len(所有形状) == 0 {
    return [[之前方案, 区域]]
  }
  首个形状 = 所有形状[0]
  该形状可放位置 = 可放位置(首个形状, 区域)
  所有方案 = []
  // [占地, 剩余区域]
  for 某位置 in 该形状可放位置 {
    占地 = 某位置[0]
    剩余区域 = 某位置[1]

    //println("新方案: " + str(之前方案))
    //[形1位置 + 形2信息[0] + 形3信息[0], 形3信息[1]])
    所有方案 = 所有方案 + 取所有摆放方案(之前方案 + [占地], 剩余区域, 所有形状[1:])
  }
  return 所有方案
}

// TODO: 方案可视化
for 方案 in 取所有摆放方案([], 部分区域, [长折, 短折, 一字]) {
  println(方案)
}

// TODO: 指定三个定点求解

/******* 测试 ******/

func 相等(目标, 实际, 信息) {
  值 = 实际
  if 值 != 目标 {
    println(信息 + "出错 -- 目标: " + str(目标) + ", 但实际为: " + str(值))
  }
}

相等(0, 点(0, 1).横, "点横坐标")
相等(1, 点(0, 1).纵, "点纵坐标")
相等(true, 点(0, 1) == 点(0, 1), "点相等")
相等(false, 点(1, 1) == 点(0, 1), "点不相等")
相等(true, 二乘二.包含点(点(1, 1)), "包含点")

相等(范围([[1, 0], [0, 0], [0, -1]]), 范围([
    [0, 1],
    [0, 0], [1, 0]
  ]).顺时针转90度(), "右旋90度")

相等(范围([
    [1, 2],
    [1, 1], [2, 1]
  ]), 占地(范围([
    [0, 1],
    [0, 0], [1, 0]
  ]), 点(1, 1)).范围, "偏移")

相等(true, 范围([
    [0, 1],
    [0, 0], [1, 0]
  ]).未超出(二乘二), "未超出")

相等(范围([[1, 1]]),
    二乘二.除去(
      范围([
        [0, 1],
        [0, 0], [1, 0]
      ])),
    "除去")

相等([
  范围([[-1, 0], [0, 0], [1, 0]]),
  范围([
    [0, 1],
    [0, 0],
    [0, -1]
  ])
], 各种朝向(范围([[-1, 0], [0, 0], [1, 0]])), "一字各种朝向")

相等(4,
  len(
    可放位置(
      范围([
        [0, 1],
        [0, 0], [1, 0]
      ]),
      二乘二
    )
  ), "可放位置")

相等(1, len(取所有摆放方案([], 三格, [一字])), "取所有摆放方案1")
相等(4, len(取所有摆放方案([], 二乘二, [短折])), "取所有摆放方案2")
相等(62, len(取所有摆放方案([], 全区, [长折, 短折, 一字])), "取所有摆放方案3")
