using pygame
using Enum in enum

type 棋手 : Enum {
  {
    X = 1
    O = 2
  }
}

type 状态 : Enum {
  {
    对弈 = 1
    X胜 = 2
    O胜 = 3
  }
}

所有落子 = [] // 储存落在棋盘上的棋子。TODO: 类型化
进行状态 = 状态.对弈
哪方 = 棋手.X

边框 = 60
格子尺寸 = 100
圆子半径 = 格子尺寸 / 2
格数 = 3
棋盘内边长 = 格子尺寸 * 格数
棋盘尺寸 = 棋盘内边长 + 边框 * 2

背景色 = tuple(208, 104, 0)
黑色 = tuple(0,0,0)
红色 = tuple(255,0,0)
线宽 = 5


func 画格子() {
  for x in 0..格数 {
    位置 = 格子尺寸 * x + 边框
    pygame.draw.line(屏幕, 黑色, tuple(位置, 边框), tuple(位置, 棋盘内边长 + 边框), 线宽)
    pygame.draw.line(屏幕, 黑色, tuple(边框, 位置), tuple(棋盘内边长 + 边框, 位置), 线宽)
  }
}

func 画棋子(落子) {
  横格, 纵格, 何方落子 = 落子
  右x = (横格 + 1) * 格子尺寸 + 边框
  左x = 横格 * 格子尺寸 + 边框
  上y = (纵格 + 1) * 格子尺寸 + 边框
  下y = 纵格 * 格子尺寸 + 边框
  if 何方落子 == 棋手.X {
    pygame.draw.line(屏幕, 黑色, tuple(左x, 下y), tuple(右x, 上y), 8)
    pygame.draw.line(屏幕, 黑色, tuple(右x, 下y), tuple(左x, 上y), 8)
  } else {
    pygame.draw.circle(屏幕, 黑色, tuple(左x + 圆子半径, 下y + 圆子半径), 圆子半径, 线宽)
  }
}

func 该位置已占(横格, 纵格) {
  return 所有落子.__contains__(tuple(横格, 纵格, 棋手.X)) or 所有落子.__contains__(tuple(横格, 纵格, 棋手.O))
}

func 胜负已分() {
  棋盘数据 = []
  // 定义棋盘的棋子下落情况 不能用 [[0]*3]*3  单个棋子的摆放会被重复赋值
  for i in 1..3 {
    棋盘数据.append([0]*3)
  }
  for x , y , z in 所有落子 {
    棋盘数据 [y][x] = 1 if z == 哪方
  }

  末子横格 = 所有落子[-1][0]
  末子纵格 = 所有落子[-1][1]
  获胜方式 = [
    [tuple(-1,0), tuple(1,0)],
    [tuple(0,-1), tuple(0,1)],
    [tuple(-1,-1), tuple(1,1)],
    [tuple(-1,1), tuple(1,-1)]] //判断获胜的四个方向

  for 起点, 终点 in 获胜方式 {
    dx , dy = 起点
    起点方向个数 = 数子(末子横格, 末子纵格, dx, dy, 棋盘数据)
    dx , dy = 终点
    终点方向个数 = 数子(末子横格, 末子纵格, dx, dy, 棋盘数据)
    if 起点方向个数 + 终点方向个数 + 1 >= 3 {
      print(起点方向个数+终点方向个数)
      return true
    }
  }
  return false
}

func 数子(lx , ly , dx , dy ,c) {
  tx , ty = lx , ly
  s = 0
  while true {
    tx += dx
    ty += dy
    if  tx < 0 or tx >= 3 or ty < 0 or ty >= 3 or c[ty][tx] == 0 {
      return s
    }
    s += 1
  }
}

pygame.init()
pygame.display.set_caption('井字棋')
屏幕 = pygame.display.set_mode(tuple(棋盘尺寸, 棋盘尺寸))
loop {
  for 事件 in pygame.event.get() {
    事件类型 = 事件.__getattribute__('type')
    if 事件类型 == pygame.QUIT {
      pygame.quit()
      quit()
    } elif 进行状态 == 状态.对弈 and 事件类型 == pygame.MOUSEBUTTONUP {
      x, y = pygame.mouse.get_pos()
      if x > 边框 and x < 棋盘内边长 + 边框 and y > 边框 and y < 棋盘内边长 + 边框 {
        横格 = int((x - 边框) * 1.0 / 格子尺寸)
        纵格 = int((y - 边框) * 1.0 / 格子尺寸)
        if !该位置已占(横格, 纵格) {
          所有落子.append(tuple(横格, 纵格, 哪方))
          if 胜负已分() {
            进行状态 = 哪方 == 棋手.X ? 状态.X胜 : 状态.O胜
          } else {
            哪方 = 哪方 == 棋手.X ? 棋手.O : 棋手.X
          }
        }
      }
    }
  }
  屏幕.fill(背景色)
  画格子()

  for 落子 in 所有落子 {
    画棋子(落子)
  }

  宣布 = 进行状态 != 状态.对弈 ?
    ((进行状态 == 状态.X胜 ? 'X' : 'O') + " 赢了!!")
    : (len(所有落子) == 9 ? "平局" : "")
  // 比赛结束
  if 宣布 != "" {
    字体 = pygame.font.Font(nil, 50)
    文字 = 字体.render(宣布, true, 红色)
    屏幕.blit(文字, tuple(20,190))
  }

  pygame.display.update()
}
