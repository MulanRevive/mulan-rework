using Enum in enum

/* 不依赖 pygame, 易于测试
TODO: 格数作参数, 可复用于其他对弈棋类 */

格数 = 3
赢了 = 3

type 棋手 : Enum {
  {
    X = 1
    O = 2
  }
}

type 状态 : Enum {
  {
    对弈 = 1
    X胜 = 2
    O胜 = 3
  }
}

所有落子 = [] // 储存落在棋盘上的棋子。TODO: 类型化

func 该位置已占(横格, 纵格) {
  return 所有落子.__contains__(tuple(横格, 纵格, 棋手.X)) or 所有落子.__contains__(tuple(横格, 纵格, 棋手.O))
}

func 胜负已分(哪方) {
  // TODO：与 所有落子 合并
  棋盘数据 = []
  // 定义棋盘的棋子下落情况 不能用 [[0] * n] * n  单个棋子的摆放会被重复赋值
  for i in 1..格数 {
    棋盘数据.append([0] * 格数)
  }
  for x , y , z in 所有落子 {
    棋盘数据[x][y] = 1 if z == 哪方
  }

  末子横格 = 所有落子[-1][0]
  末子纵格 = 所有落子[-1][1]
  获胜方式 = [
    [tuple(-1,0), tuple(1,0)],
    [tuple(0,-1), tuple(0,1)],
    [tuple(-1,-1), tuple(1,1)],
    [tuple(-1,1), tuple(1,-1)]] //判断获胜的四个方向

  for 起点, 终点 in 获胜方式 {
    dx, dy = 起点
    起点方向个数 = 数子(末子横格, 末子纵格, dx, dy, 棋盘数据)
    dx, dy = 终点
    终点方向个数 = 数子(末子横格, 末子纵格, dx, dy, 棋盘数据)
    if 起点方向个数 + 终点方向个数 + 1 >= 赢了 {
      return true
    }
  }
  return false
}

func 数子(lx, ly, dx, dy, 棋盘) {
  tx, ty = lx, ly
  个数 = 0
  while true {
    tx += dx
    ty += dy
    if !在棋盘内(tx, ty) or 棋盘[tx][ty] == 0 {
      return 个数
    }
    个数 += 1
  }
}

func 在棋盘内(横格, 纵格) {
  return 横格 >= 0 and 横格 < 格数 and 纵格 >= 0 and 纵格 < 格数
}

func 落子(横格, 纵格, 哪方) {
  可落子 = 在棋盘内(横格, 纵格) and !该位置已占(横格, 纵格)
  所有落子.append(tuple(横格, 纵格, 哪方)) if 可落子
  return 可落子
}