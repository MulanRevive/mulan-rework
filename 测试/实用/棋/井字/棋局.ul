using Enum in enum

using 相等 in 测试.实用.通用.测试相关

/* 不依赖 pygame, 易于测试
TODO: 格数作参数, 可复用于其他对弈棋类 */

格数 = 3
赢了 = 3

type 棋手 : Enum {
  {
    X = 1
    O = 2
  }
}

type 状态 : Enum {
  {
    对弈 = 1
    X胜 = 2
    O胜 = 3
  }
}

type 步 {
  func $步(横, 纵, 棋手) {
    $横, $纵, $棋手 = 横, 纵, 棋手
  }

  operator == (另一子) {
    return $横 == 另一子.横 and $纵 == 另一子.纵 and $棋手 == 另一子.棋手
  }

  func __repr__(self) {
    return "(`$棋手`: (`$横`, `$纵`))"
  }
}

type 棋盘状况 {
  func $棋盘状况() {
    $所有子 = []
    $进行状态 = 状态.对弈
    $当前棋手 = 棋手.X
  }

  func $落子(所在格) {
    横格, 纵格 = 所在格[0], 所在格[1]
    可落子 = $进行状态 == 状态.对弈 and 在棋盘内(横格, 纵格) and !$位置已占(横格, 纵格)
    if 可落子 {
      $所有子.append(步(横格, 纵格, $当前棋手))
      $当前棋手 = $当前棋手 == 棋手.X ? 棋手.O : 棋手.X
    }
    $已赢()
    return 可落子
  }

  func $位置已占(横格, 纵格) {
    return any(map(某子 -> 某子.横 == 横格 and 某子.纵 == 纵格, $所有子))
  }

  func $已赢() {
    return false if len($所有子) < 3
    末子 = $所有子[-1]
    末子棋手 = 末子.棋手
    获胜方式 = [
      [tuple(-1, 0), tuple(1, 0)],
      [tuple(0, -1), tuple(0, 1)],
      [tuple(-1, -1), tuple(1, 1)],
      [tuple(-1, 1), tuple(1, -1)]] //判断获胜的四个方向

  for 起点, 终点 in 获胜方式 {
    dx, dy = 起点
    起点方向个数 = 数子(末子, dx, dy)
    dx, dy = 终点
    终点方向个数 = 数子(末子, dx, dy)
    if 起点方向个数 + 终点方向个数 + 1 == 赢了 {
      $进行状态 = 末子棋手 == 棋手.X ? 状态.X胜 : 状态.O胜
      return true
    }
  }
  return false
  }
}

状况 = 棋盘状况()

func 数子(末子, dx, dy) {
  tx, ty = 末子.横, 末子.纵
  个数 = 0
  while true {
    tx += dx
    ty += dy
    if 在棋盘内(tx, ty) and 状况.所有子.__contains__(步(tx, ty, 末子.棋手)) {
      个数 += 1
    } else {
      return 个数
    }
  }
}

func 在棋盘内(横格, 纵格) {
  return 横格 >= 0 and 横格 < 格数 and 纵格 >= 0 and 纵格 < 格数
}

相等(false, [步(1, 1, 棋手.O)].__contains__(步(1, 1, 棋手.X)), "包含步")
相等(true, [步(1, 1, 棋手.O)].__contains__(步(1, 1, 棋手.O)), "包含步")
