### 1 实例函数调用println的两种声明方法，调用结果不同

#### 1.1 问题描述
如下所示，在执行过程中出现如下状况，当使用`a=println`时，不符合期望值。
```
> type C { { a = println } }
> C().a('o')
<__main__.C object at 0x000000000319E0C8> o
> type C1 { {} func a(t) {println(t)} }
> C1().a('o')
o
```

#### 1.2 问题原因
println的原型为:
```
'print': 自定义输出,
'println': lambda *各物件: 自定义输出(*各物件, **{'终止符': '\n'}),
```
即使用println输出时调用print(*各物件)，如上例，当使用`a`做为`C`类成员函数时，`a`的执行过程会添加一个`self`参数，
所以输出时会把类本身出输出。在成员函数内部调用时，只会输出给定参数内容，则不会出现此情况。

通过调试代码发现，添加`self`参数的并不是项目中的代码，实际是python执行中添加，如下python代码所示：
```python
class C:
    a = lambda *v: print(*v)
C().a('o')
```
输出时同样会输出self对象，结果如下：
```
<__main__.C object at 0xxxx> o
```

#### 1.3 其它说明
原始木兰执行时，也会出现相同情况，为保持一致性，所以不需要对`自定义输出`函数做出修正。