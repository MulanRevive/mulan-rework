
using * in 木兰.分析器.词法分析器

using 代码段 in 编辑器.代码段
using * in 编辑器.常量
using * in 编辑器.日志

using 按某项生成映射 in 测试.实用.通用.结构

func 解析(源码) {
  各词 = 分词器.lex(源码)

  各代码段 = list(map(词 -> {
    行号 = 词.getsourcepos().lineno
    列号 = 词.getsourcepos().colno - 1
    内容 = 词.getstr()
    词长 = len(内容)
    词性 = 词.name
    if 词性 == 标识符 {
      if 内置函数表.__contains__(内容) {
        词性 = 内置函数
      } elif 内置类型表.__contains__(内容) {
        词性 = 内置类型
      } elif 内容 == 自身 {
        词性 = 自身
      }
    }
    return 代码段(词性, 内容, 行号, 列号, 列号 + 词长)
  }, 各词))
  各行代码段 = 按某项生成映射(各代码段, 段 -> 段.行, 段 -> 段)

  所有行 = 源码.splitlines()
  for 索引 in range(len(所有行)) {
    行号 = 索引 + 1
    列号 = 0
    完整代码段 = []
    // 取本行所有代码段, 将跳过部分全部置为注释 TODO: 保险起见最好再次检查是否为注释
    if 各行代码段.__contains__(行号) {
      本行代码段 = 各行代码段.get(行号)
      for 段 in 本行代码段 {
        if 段.起 > 列号 + 1 {
          内容 = 所有行[索引][列号 : 段.起]
          词性 = 内容 == " " * (段.起 - 列号) ? 空格 : 注释
          完整代码段.append(代码段(词性, 内容, 行号, 列号, 段.起))
        }
        完整代码段.append(段)
        列号 = 段.止
      }
    }

    行长 = len(所有行[索引])
    if 列号 < 行长 {
      内容 = 所有行[索引][列号 : 行长]
      词性 = 内容 == " " * (行长 - 列号) ? 空格 : 注释
      完整代码段.append(代码段(词性, 内容, 行号, 列号, 行长))
    }
    各行代码段[行号] = 完整代码段
  }

  // TODO: 考虑直接使用 各行代码段, 今后演化为代码抽象结构(介于 AST 和文本形式之间)
  所有代码段 = []
  for 行号 in 1..len(所有行) {
    所有代码段 += 各行代码段[行号]
  }

  return 所有代码段
}

func 处理后大括号(各代码段) {
  已处理 = []
  上一代码段 = nil
  for 代码段 in 各代码段 {
    if 代码段.词性 == 后大括号 {
      换行数 = 代码段.内容.count("\n")
      代码段.行 = 代码段.行 + 换行数
      代码段.内容 = 代码段.内容[换行数:]
      代码段.止 = 代码段.止 - 代码段.起 - 换行数
      代码段.起 = 0
    } elif 代码段.位置重合(上一代码段) {
      // 除去多余注释段
      continue
    }
    已处理.append(代码段)
    上一代码段 = 代码段
  }
  return 已处理
}

func 未配对括号数(各代码段) {
  未配对 = 0
  for 代码段 in 各代码段 {
    if 代码段.词性 == 前大括号 {
      未配对 += 1
    } elif 代码段.词性 == 后大括号 {
      未配对 -= 1
    }
  }
  if 各代码段 and 各代码段[-1].词性 == 前大括号 {
    未配对 -= 1
  }
  return 未配对
}

func 全为空格(各代码段) {
  return all(map(代码段 -> 代码段.词性 == 空格, 各代码段))
}

func 格式化(源码) {
  缩进单位 = "  "
  所有行 = 源码.splitlines()
  格式源码 = []
  // 只解析一次全部代码, 遍历一次所有代码段后生成每行缩进量
  各代码段 = 处理后大括号(解析(源码))
  各行代码段 = 按某项生成映射(各代码段, 段 -> 段.行, 段 -> 段)
  每行缩进量 = {1:0}

  for 行号 in 1..len(所有行) {
    if !各行代码段.__contains__(行号) {
      每行缩进量[行号] = 0
      continue
    }
    本行代码段 = 各行代码段[行号]
    缩进增量 = 未配对括号数(本行代码段)

    if 行号 > 1 {
      上行代码段 = 各行代码段.get(行号 - 1)
      if 上行代码段 and 上行代码段[-1].词性 == 前大括号 {
        缩进增量 += 1
      }
    }

    每行缩进量[行号] = 行号 == 1 ? 缩进增量 : 每行缩进量[行号 - 1] + 缩进增量
    //logging.info(本行代码段)
    每行缩进量[行号] = 0 if 全为空格(本行代码段)
  }

  for 行号 in 1..len(所有行) {
    logging.info("`行号`行缩进量`每行缩进量[行号]`")
    格式源码.append(每行缩进量[行号] * 缩进单位 + 所有行[行号 - 1].strip())
  }
  return "\n".join(格式源码)
}
